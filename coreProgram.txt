[reverseList [Occ=LoopBreaker] :: [Integer] -> [Integer]
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 80 10}]
 reverseList
   = \ (ds_d1om :: [Integer]) ->
       case ds_d1om of {
         [] -> [] @Integer;
         : a bc -> ++ @Integer (reverseList bc) (: @Integer a ([] @Integer))
       };,
 abc :: [Integer]
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 350 0}]
 abc
   = reverseList
       (: @Integer 1 (: @Integer 2 (: @Integer 3 ([] @Integer)))),
 e :: Bool
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
 e = True,
 $trModule :: Module
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 10}]
 $trModule = Module (TrNameS "main"#) (TrNameS "Source2"#),
 f :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 160 0}]
 f = abs @Integer $fNumInteger (negate @Integer $fNumInteger 3),
 c :: Integer -> Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 40 0}]
 c = \ (x :: Integer) -> + @Integer $fNumInteger x x,
 d :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 120 0}]
 d = c 1,
 y :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 240 0}]
 y = - @Integer $fNumInteger 3 4,
 x :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 380 0}]
 x = + @Integer $fNumInteger 1 (* @Integer $fNumInteger 2 3),
 z :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
 z = + @Integer $fNumInteger x y,
 b :: Integer
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
 b = z,
 sayMe :: Integer -> String
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=NEVER}]
 sayMe
   = \ (ds_d1or :: Integer) ->
       case == @Integer $fEqInteger ds_d1or 1 of {
         False ->
           case == @Integer $fEqInteger ds_d1or 2 of {
             False ->
               case == @Integer $fEqInteger ds_d1or 3 of {
                 False ->
                   case == @Integer $fEqInteger ds_d1or 4 of {
                     False ->
                       case == @Integer $fEqInteger ds_d1or 5 of {
                         False -> unpackCString# "Not between 1 and 5"#;
                         True -> unpackCString# "Five!"#
                       };
                     True -> unpackCString# "Four!"#
                   };
                 True -> unpackCString# "Three!"#
               };
             True -> unpackCString# "Two!"#
           };
         True -> unpackCString# "One!"#
       },
 a :: String
 [LclIdX,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
          WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 120 0}]
 a = sayMe 1]